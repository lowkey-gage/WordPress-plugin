"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  count: true
};
exports.count = count;
var _defaultSettings = require("./defaultSettings");
var _stripTags = _interopRequireDefault(require("./stripTags"));
var _transposeAstralsToCountableChar = _interopRequireDefault(require("./transposeAstralsToCountableChar"));
var _stripHTMLEntities = _interopRequireDefault(require("./stripHTMLEntities"));
var _stripConnectors = _interopRequireDefault(require("./stripConnectors"));
var _stripRemovables = _interopRequireDefault(require("./stripRemovables"));
var _stripHTMLComments = _interopRequireDefault(require("./stripHTMLComments"));
var _stripShortcodes = _interopRequireDefault(require("./stripShortcodes"));
var _stripSpaces = _interopRequireDefault(require("./stripSpaces"));
var _transposeHTMLEntitiesToCountableChars = _interopRequireDefault(require("./transposeHTMLEntitiesToCountableChars"));
var _types = require("./types");
Object.keys(_types).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _types[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _types[key];
    }
  });
});
/**
 * Internal dependencies
 */

/**
 * Private function to manage the settings.
 *
 * @param type         The type of count to be done.
 * @param userSettings Custom settings for the count.
 * @return The combined settings object to be used.
 */
function loadSettings(type = 'words', userSettings = {}) {
  var _settings$l10n$shortc;
  const mergedSettings = {
    ..._defaultSettings.defaultSettings,
    ...userSettings
  };
  const settings = {
    ...mergedSettings,
    type,
    shortcodes: []
  };
  settings.shortcodes = (_settings$l10n$shortc = settings.l10n?.shortcodes) !== null && _settings$l10n$shortc !== void 0 ? _settings$l10n$shortc : [];
  if (settings.shortcodes && settings.shortcodes.length) {
    settings.shortcodesRegExp = new RegExp('\\[\\/?(?:' + settings.shortcodes.join('|') + ')[^\\]]*?\\]', 'g');
  }
  if (settings.type !== 'characters_excluding_spaces' && settings.type !== 'characters_including_spaces') {
    settings.type = 'words';
  }
  return settings;
}

/**
 * Count the words in text
 *
 * @param text     The text being processed
 * @param regex    The regular expression pattern being matched
 * @param settings Settings object containing regular expressions for each strip function
 * @return Count of words.
 */
function countWords(text, regex, settings) {
  var _text$match$length;
  text = [_stripTags.default.bind(null, settings), _stripHTMLComments.default.bind(null, settings), _stripShortcodes.default.bind(null, settings), _stripSpaces.default.bind(null, settings), _stripHTMLEntities.default.bind(null, settings), _stripConnectors.default.bind(null, settings), _stripRemovables.default.bind(null, settings)].reduce((result, fn) => fn(result), text);
  text = text + '\n';
  return (_text$match$length = text.match(regex)?.length) !== null && _text$match$length !== void 0 ? _text$match$length : 0;
}

/**
 * Count the characters in text
 *
 * @param text     The text being processed
 * @param regex    The regular expression pattern being matched
 * @param settings Settings object containing regular expressions for each strip function
 * @return Count of characters.
 */
function countCharacters(text, regex, settings) {
  var _text$match$length2;
  text = [_stripTags.default.bind(null, settings), _stripHTMLComments.default.bind(null, settings), _stripShortcodes.default.bind(null, settings), _transposeAstralsToCountableChar.default.bind(null, settings), _stripSpaces.default.bind(null, settings), _transposeHTMLEntitiesToCountableChars.default.bind(null, settings)].reduce((result, fn) => fn(result), text);
  text = text + '\n';
  return (_text$match$length2 = text.match(regex)?.length) !== null && _text$match$length2 !== void 0 ? _text$match$length2 : 0;
}

/**
 * Count some words.
 *
 * @param text         The text being processed
 * @param type         The type of count. Accepts 'words', 'characters_excluding_spaces', or 'characters_including_spaces'.
 * @param userSettings Custom settings object.
 *
 * @example
 * ```ts
 * import { count } from '@wordpress/wordcount';
 * const numberOfWords = count( 'Words to count', 'words', {} )
 * ```
 *
 * @return The word or character count.
 */
function count(text, type, userSettings) {
  const settings = loadSettings(type, userSettings);
  let matchRegExp;
  switch (settings.type) {
    case 'words':
      matchRegExp = settings.wordsRegExp;
      return countWords(text, matchRegExp, settings);
    case 'characters_including_spaces':
      matchRegExp = settings.characters_including_spacesRegExp;
      return countCharacters(text, matchRegExp, settings);
    case 'characters_excluding_spaces':
      matchRegExp = settings.characters_excluding_spacesRegExp;
      return countCharacters(text, matchRegExp, settings);
    default:
      return 0;
  }
}

// Export types for external usage
//# sourceMappingURL=index.js.map