"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ControlWithError = void 0;
var _compose = require("@wordpress/compose");
var _i18n = require("@wordpress/i18n");
var _element = require("@wordpress/element");
var _withIgnoreImeEvents = require("../utils/with-ignore-ime-events");
var _validityIndicator = require("./validity-indicator");
var _jsxRuntime = require("react/jsx-runtime");
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

function appendRequiredIndicator(label, required, markWhenOptional) {
  if (required && !markWhenOptional) {
    return /*#__PURE__*/(0, _jsxRuntime.jsxs)(_jsxRuntime.Fragment, {
      children: [label, " ", `(${(0, _i18n.__)('Required')})`]
    });
  }
  if (!required && markWhenOptional) {
    return /*#__PURE__*/(0, _jsxRuntime.jsxs)(_jsxRuntime.Fragment, {
      children: [label, " ", `(${(0, _i18n.__)('Optional')})`]
    });
  }
  return label;
}

/**
 * HTML elements that support the Constraint Validation API.
 *
 * Here, we exclude HTMLButtonElement because although it does technically support the API,
 * normal buttons are actually exempted from any validation.
 * @see https://developer.mozilla.org/en-US/docs/Learn_web_development/Extensions/Forms/Form_validation
 * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLButtonElement/willValidate
 */

function UnforwardedControlWithError({
  required,
  markWhenOptional,
  onValidate,
  customValidity,
  getValidityTarget,
  children
}, forwardedRef) {
  const [errorMessage, setErrorMessage] = (0, _element.useState)();
  const [statusMessage, setStatusMessage] = (0, _element.useState)();
  const [isTouched, setIsTouched] = (0, _element.useState)(false);
  const previousCustomValidityType = (0, _compose.usePrevious)(customValidity?.type);

  // Ensure that error messages are visible after user attemps to submit a form
  // with multiple invalid fields.
  (0, _element.useEffect)(() => {
    const validityTarget = getValidityTarget();
    const showValidationMessage = () => setErrorMessage(validityTarget?.validationMessage);
    validityTarget?.addEventListener('invalid', showValidationMessage);
    return () => {
      validityTarget?.removeEventListener('invalid', showValidationMessage);
    };
  });
  (0, _element.useEffect)(() => {
    if (!isTouched) {
      return;
    }
    const validityTarget = getValidityTarget();
    if (!customValidity?.type) {
      validityTarget?.setCustomValidity('');
      setErrorMessage(validityTarget?.validationMessage);
      setStatusMessage(undefined);
      return;
    }
    switch (customValidity.type) {
      case 'validating':
        {
          // Wait before showing a validating state.
          const timer = setTimeout(() => {
            validityTarget?.setCustomValidity('');
            setErrorMessage(undefined);
            setStatusMessage({
              type: 'validating',
              message: customValidity.message
            });
          }, 1000);
          return () => clearTimeout(timer);
        }
      case 'valid':
        {
          // Ensures that we wait for any async responses before showing
          // a synchronously valid state.
          if (previousCustomValidityType === 'valid') {
            break;
          }
          validityTarget?.setCustomValidity('');
          setErrorMessage(validityTarget?.validationMessage);
          setStatusMessage({
            type: 'valid',
            message: customValidity.message
          });
          break;
        }
      case 'invalid':
        {
          var _customValidity$messa;
          validityTarget?.setCustomValidity((_customValidity$messa = customValidity.message) !== null && _customValidity$messa !== void 0 ? _customValidity$messa : '');
          setErrorMessage(validityTarget?.validationMessage);
          setStatusMessage(undefined);
          break;
        }
    }
  }, [isTouched, customValidity?.type, customValidity?.message, getValidityTarget, previousCustomValidityType]);
  const onBlur = event => {
    if (isTouched) {
      return;
    }

    // Only consider "blurred from the component" if focus has fully left the wrapping div.
    // This prevents unnecessary blurs from components with multiple focusable elements.
    if (!event.relatedTarget || !event.currentTarget.contains(event.relatedTarget)) {
      setIsTouched(true);
      onValidate?.();
    }
  };
  const onChange = (...args) => {
    children.props.onChange?.(...args);

    // Only validate incrementally if the field has blurred at least once,
    // or currently has an error message.
    if (isTouched || errorMessage) {
      onValidate?.();
    }
  };
  const onKeyDown = event => {
    // Ensures that custom validators are triggered when the user submits by pressing Enter,
    // without ever blurring the control.
    if (event.key === 'Enter') {
      onValidate?.();
    }
  };
  return (
    /*#__PURE__*/
    // Disable reason: Just listening to a bubbled event, not for interaction.
    // eslint-disable-next-line jsx-a11y/no-static-element-interactions
    (0, _jsxRuntime.jsxs)("div", {
      className: "components-validated-control",
      ref: forwardedRef,
      onBlur: onBlur,
      onKeyDown: (0, _withIgnoreImeEvents.withIgnoreIMEEvents)(onKeyDown),
      children: [(0, _element.cloneElement)(children, {
        label: appendRequiredIndicator(children.props.label, required, markWhenOptional),
        onChange,
        required
      }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
        "aria-live": "polite",
        children: [errorMessage && /*#__PURE__*/(0, _jsxRuntime.jsx)(_validityIndicator.ValidityIndicator, {
          type: "invalid",
          message: errorMessage
        }), !errorMessage && statusMessage && /*#__PURE__*/(0, _jsxRuntime.jsx)(_validityIndicator.ValidityIndicator, {
          type: statusMessage.type,
          message: statusMessage.message
        })]
      })]
    })
  );
}
const ControlWithError = exports.ControlWithError = (0, _element.forwardRef)(UnforwardedControlWithError);
//# sourceMappingURL=control-with-error.js.map